<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blazor WASM Packager</title>
    <style>
        body {
            font-family: "Microsoft YaHei", Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            max-width: 1000px;
            margin: 0 auto;
        }

        .intro {
            margin-bottom: 20px;
            line-height: 1.6;
            width: 800px;
        }

        .output-filename-container {
            width: 800px;
            margin: 10px 0;
        }

            .output-filename-container label {
                display: block;
                margin-bottom: 5px;
                font-weight: 500;
            }

        #outputFileNameInput {
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-family: monospace;
        }

        .merge-files-container {
            width: 800px;
            margin: 15px 0;
        }

            .merge-files-container label {
                display: block;
                margin-bottom: 8px;
                font-weight: 500;
            }

        #mergeFilesInput {
            width: 100%;
            height: 100px;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-family: monospace;
            resize: vertical;
        }

        .minify-option {
            margin: 10px 0;
            display: flex;
            align-items: center;
        }

        #minifyMergeJs {
            margin-right: 8px;
            width: 16px;
            height: 16px;
        }
        #removeImportMergeJs {
            margin-right: 8px;
            width: 16px;
            height: 16px;
        }

        .merge-files-hint, .filename-hint {
            font-size: 0.85em;
            color: #666;
            margin-top: 5px;
        }

        #progressContainer {
            width: 800px;
            height: 24px;
            background-color: #f0f0f0;
            border-radius: 12px;
            margin: 15px 0;
            overflow: hidden;
            position: relative;
            border: 1px solid #ddd;
        }

        #progressBar {
            height: 100%;
            width: 0%;
            background-color: #4CAF50;
            transition: width 0.3s ease;
        }

        #progressText {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            padding-left: 10px;
            font-size: 0.9em;
            color: #000;
            pointer-events: none;
            text-align: left;
            font-weight: 500;
        }

        #debugOutput {
            width: 800px;
            height: 300px;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 10px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.9em;
            white-space: pre-wrap;
            margin: 10px 0;
        }

        .report {
            width: 800px;
            margin: 15px 0;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f9f9fa;
        }

            .report h3 {
                margin-top: 0;
                color: #333;
            }

            .report p {
                margin: 5px 0;
            }

        .download-link {
            display: inline-block;
            margin-top: 10px;
            padding: 8px 16px;
            background-color: #007bff;
            color: white;
            text-decoration: none;
            border-radius: 4px;
            font-size: 0.9em;
        }

            .download-link:hover {
                background-color: #0056b3;
            }

        button {
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }

            button:disabled {
                background-color: #6c757d;
                cursor: not-allowed;
            }

        .note {
            color: #666;
            font-size: 0.9em;
            margin-top: 10px;
            padding: 8px;
            background-color: #f8f9fa;
            border-radius: 4px;
            width: 800px;
        }

        .copyright {
            margin-top: 20px;
            color: #666;
            font-size: 0.9em;
        }

        .size-info {
            font-weight: bold;
            color: #007bff;
        }
    </style>
</head>
<body>
    <h1>Blazor WASM Packager</h1>
    <div class="intro">
        <p>Release Date: October 30, 2025. Website: <a href="https://github.com/dcsoft-yyf/BlazorWASMPackager">https://github.com/dcsoft-yyf/BlazorWASMPackager</a></p>
        <p>This tool packages core resource files of a Blazor WebAssembly application into a single JS file, supporting Blazor WASM 7.0/8.0/9.0. Place this HTML file in the root directory of your Blazor WASM application (parent directory of _framework), and after clicking the button below, the program will:</p>
        <ol>
            <li>Parse the <code>_framework/blazor.boot.json</code> configuration file (and include it in the package)</li>
            <li>Force package all resource files listed in boot.json (including JS files)</li>
            <li>Download these resource files and apply maximum GZIP compression</li>
            <li>Merge user-specified custom scripts into Merge.js and include in the package (optional)</li>
            <li>Generate a JavaScript file containing all resources and provide download</li>
        </ol>
    </div>

    <!-- Output filename input area -->
    <div class="output-filename-container">
        <label for="outputFileNameInput">Generated JS filename:</label>
        <input type="text" id="outputFileNameInput"  placeholder="e.g.: MyApp.published.js">
        <div class="filename-hint">Hint: Leave empty to use default filename (entryAssembly value + .published.js). Ensure it includes .js extension.</div>
    </div>

    <!-- Custom script input area -->
    <div class="merge-files-container">
        <label for="mergeFilesInput">Custom JS files to merge (one per line, relative to _framework directory):</label>
        <textarea id="mergeFilesInput" placeholder="e.g.:
custom-script-1.js
scripts/custom-script-2.js">
</textarea>
        <div class="minify-option">
            <input type="checkbox" id="minifyMergeJs">
            <label for="minifyMergeJs">Remove comments and unnecessary whitespace when merging custom scripts (handles template strings and regular expressions)</label>
        </div>
        <div class="minify-option">
            <input type="checkbox" id="removeImportMergeJs" checked>
            <label for="removeImportMergeJs">Remove <i>import {name} from "a.js"</i> directives when merging custom scripts</label>
        </div>

        <div class="merge-files-hint">Hint: Enter custom JS filenames to merge into Merge.js and include in the result. Leave empty to not generate Merge.js.</div>
    </div>

    <button id="downloadBtn" onclick="processAndDownload()">Package and Download Resource Files</button>

    <div id="progressContainer">
        <div id="progressBar"></div>
        <div id="progressText">Ready</div>
    </div>

    <div>
        <h3>Processing Log</h3>
        <div id="debugOutput"></div>
    </div>

    <!-- Summary report area -->
    <div class="report" id="summaryReport" style="display: none;">
        <h3>Packaging Summary Report</h3>
        <p>Original files total size: <span id="originalTotalSize" class="size-info">-</span></p>
        <p>Generated JS file size (UTF-8 encoding): <span id="jsFileSize" class="size-info">-</span></p>
        <p>Compression ratio: <span id="compressionRatio" class="size-info">-</span></p>
        <a id="manualDownloadLink" href="#" class="download-link">Manually download generated resource file</a>
    </div>

    <div class="note">
        <strong>Note:</strong> Ensure this page runs in the root directory of the Blazor WASM application to correctly access files in the <code>_framework</code> directory. Processing time depends on the number and size of resource files, please be patient.
    </div>

    <div class="copyright">Copyright Â© Nanjing DC Information Technology Co., Ltd. All rights reserved.</div>

    <script>
        const debugOutputEl = document.getElementById('debugOutput');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const summaryReport = document.getElementById('summaryReport');
        const manualDownloadLink = document.getElementById('manualDownloadLink');
        const mergeFilesInput = document.getElementById('mergeFilesInput');
        const minifyMergeJs = document.getElementById('minifyMergeJs');
        const outputFileNameInput = document.getElementById('outputFileNameInput');
        let blobUrl = null;

        // Format byte sizes
        function formatBytes(bytes) {
            if (bytes === 0) return '0 Bytes';

            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));

            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function logDebugMessage(message) {
            debugOutputEl.textContent += message + '\n';
            debugOutputEl.scrollTop = debugOutputEl.scrollHeight;
        }

        function clearDebugOutput() {
            debugOutputEl.textContent = '';
        }

        function updateProgress(percent, text) {
            progressBar.style.width = `${percent}%`;
            progressText.textContent = text || `${percent.toFixed(1)}%`;
        }

        // Reset progress bar
        function resetProgressBar() {
            updateProgress(0, 'Ready');
        }

        function CleanJavaScriptCode(strJSContent, removeComment, removeImport) {
            // Sub-function: Check if this is the start of a regex
            function isStartOfRegex(code, pos) {
                // Check if current position might be the start of a regex
                // Look backwards to see if we're after an operator
                let i = pos - 1;
                while (i >= 0 && /\s/.test(code[i])) {
                    i--;
                }

                if (i < 0) return true; // If at start, might be regex

                const prevChar = code[i];

                // If previous char is one of these operators, likely regex
                const regexStarters = ['(', '=', ',', '[', '!', '&', '|', '?', ':', ';', '{', '}', '~', '*'];
                if (regexStarters.includes(prevChar)) {
                    return true;
                }

                // Check if after keywords (like return, typeof, etc.)
                const keywordCheck = code.substring(0, i + 1);
                const keywords = ['return', 'typeof', 'instanceof', 'new', 'delete', 'void', 'yield'];

                for (const keyword of keywords) {
                    const keywordPos = keywordCheck.lastIndexOf(keyword);
                    if (keywordPos >= 0) {
                        const afterKeyword = keywordCheck.substring(keywordPos + keyword.length, i + 1).trim();
                        if (afterKeyword === '') {
                            return true;
                        }
                    }
                }

                // If after other characters (like variable names), not regex
                if (/[a-zA-Z0-9_$]/.test(prevChar)) {
                    return false;
                }

                return true;
            }

            // Sub-function: Find end of regex expression
            function findRegexEnd(code, startPos) {
                let i = startPos + 1; // Skip starting /

                while (i < code.length) {
                    const char = code[i];

                    if (char === '\\') {
                        // Skip escape characters
                        i += 2;
                        continue;
                    }

                    if (char === '/') {
                        // Found end of regex
                        i++;
                        // Check for modifiers
                        while (i < code.length && /[gimysu]/.test(code[i])) {
                            i++;
                        }
                        return i;
                    }

                    i++;
                }

                // If no end found, return original position
                return startPos;
            }

            let result = strJSContent;

            // Process import statements
            if (removeImport === true) {
                // Match various import statement formats
                result = result.replace(/^\s*import\s+.*?from\s+["'][^"']*["']\s*;?\s*$/gm, '');
                result = result.replace(/^\s*import\s+["'][^"']*["']\s*;?\s*$/gm, '');
                result = result.replace(/^\s*import\s+\{.*?\}\s+from\s+["'][^"']*["']\s*;?\s*$/gm, '');
                result = result.replace(/^\s*import\s+\*\s+as\s+\w+\s+from\s+["'][^"']*["']\s*;?\s*$/gm, '');
            }

            if (removeComment === true) {
                let cleanedCode = '';
                let i = 0;
                const len = result.length;

                while (i < len) {
                    const char = result[i];
                    const nextChar = i < len - 1 ? result[i + 1] : '';

                    // Check if in string
                    if (char === '"' || char === "'" || char === '`') {
                        const quote = char;
                        cleanedCode += char;
                        i++;

                        // Process string content, including escape characters
                        while (i < len) {
                            const currentChar = result[i];
                            cleanedCode += currentChar;

                            if (currentChar === '\\') {
                                // Skip escape character
                                i++;
                                if (i < len) {
                                    cleanedCode += result[i];
                                }
                            } else if (currentChar === quote) {
                                // Found end of string
                                i++;
                                break;
                            }
                            i++;
                        }
                        continue;
                    }

                    if (char === '/') {
                        // Check if this is a regex
                        const isRegex = isStartOfRegex(result, i);

                        if (isRegex) {
                            const regexEnd = findRegexEnd(result, i);
                            cleanedCode += result.substring(i, regexEnd);
                            i = regexEnd;
                            continue;
                        }
                    }

                    // Check for comments
                    if (char === '/' && nextChar === '/') {
                        // Single-line comment
                        i += 2;
                        while (i < len && result[i] !== '\n') {
                            i++;
                        }
                        // Keep newline
                        if (i < len) {
                            cleanedCode += result[i];
                            i++;
                        }
                        continue;
                    }

                    if (char === '/' && nextChar === '*') {
                        // Multi-line comment
                        i += 2;
                        while (i < len - 1 && !(result[i] === '*' && result[i + 1] === '/')) {
                            i++;
                        }
                        if (i < len - 1) {
                            i += 2;
                        }
                        continue;
                    }

                    // Normal character
                    cleanedCode += char;
                    i++;
                }

                // Remove extra blank lines and leading/trailing spaces
                result = cleanedCode
                    .split('\n')
                    .map(line => line.trim())
                    .filter(line => line !== '')
                    .join('\n');
            }

            return result;
        }


        /**
         * GZIP compress with maximum compression level
         */
        async function gzipCompress(uint8Array) {
            const cs = new CompressionStream('gzip', { level: 9 });
            const writer = cs.writable.getWriter();
            writer.write(uint8Array);
            writer.close();

            const compressedChunks = [];
            const reader = cs.readable.getReader();
            let done, value;
            while ({ done, value } = await reader.read(), !done) {
                compressedChunks.push(value);
            }

            const totalLength = compressedChunks.reduce((acc, chunk) => acc + chunk.length, 0);
            const compressed = new Uint8Array(totalLength);
            let offset = 0;
            for (const chunk of compressedChunks) {
                compressed.set(chunk, offset);
                offset += chunk.length;
            }

            return compressed;
        }

        function uint8ArrayToBase64(uint8Array) {
            const CHUNK_SIZE = 129;
            let base64 = '';
            let isFirstChunk = true;

            for (let i = 0; i < uint8Array.length; i += CHUNK_SIZE) {
                const chunk = uint8Array.subarray(i, i + CHUNK_SIZE);

                let binary = '';
                for (let j = 0; j < chunk.length; j++) {
                    binary += String.fromCharCode(chunk[j]);
                }

                const chunkBase64 = btoa(binary);

                if (!isFirstChunk) {
                    base64 += '\n';
                } else {
                    isFirstChunk = false;
                }

                base64 += chunkBase64;
            }

            return base64;
        }

        function escapeJsKey(key) {
            if (/[^a-zA-Z0-9_$]/.test(key)) {
                return `"${key.replace(/"/g, '\\"')}"`;
            }
            return key;
        }

        /**
         * Process user-specified custom JS file merging
         */
        async function processCustomJsFiles(originalTotalBytes) {
            // Get user input filenames, remove empty lines and leading/trailing spaces
            const inputText = mergeFilesInput.value.trim();
            if (!inputText) {
                logDebugMessage('No custom JS files specified, not generating Merge.js');
                return { originalTotalBytes, fileEntries: [] };
            }

            // Parse input filename list
            const filenames = inputText.split('\n')
                .map(line => line.trim())
                .filter(line => line); // Filter empty lines

            if (filenames.length === 0) {
                logDebugMessage('No valid custom JS files specified, not generating Merge.js');
                return { originalTotalBytes, fileEntries: [] };
            }

            // Get minification options
            const shouldMinify = document.getElementById('minifyMergeJs').checked;
            const shouldRemoveImportMergeJs = document.getElementById("removeImportMergeJs").checked;
            logDebugMessage(`Processing ${filenames.length} custom JS files: ${filenames.join(', ')} ${shouldMinify ? '(will minify code)' : ''}`);

            // Download and merge all specified JS files
            let mergedContent = '';
            let mergeFileEntries = [];
            let originalMergedSize = 0;

            for (const filename of filenames) {
                try {
                    logDebugMessage(`Downloading: ${filename}`);
                    const response = await fetch(`_framework/${filename}`);
                    if (!response.ok) {
                        throw new Error(`Download failed (${response.status})`);
                    }

                    let content = await response.text();
                    const originalFileSize = new TextEncoder().encode(content).length;
                    originalTotalBytes += originalFileSize;
                    originalMergedSize += originalFileSize;

                    // If minification needed, process individual file content
                    if (shouldMinify === true || shouldRemoveImportMergeJs === true) {
                        const minifiedContent = CleanJavaScriptCode(content, shouldMinify, shouldRemoveImportMergeJs);
                        content = minifiedContent;
                    }

                    // Add to merged content (keep source comments unless minifying)
                    if (!shouldMinify) {
                        mergedContent += `// From: ${filename}\n`;
                    }
                    mergedContent += content;
                    mergedContent += shouldMinify ? ';' : '\n\n';

                } catch (error) {
                    logDebugMessage(`Error processing ${filename}: ${error.message}, skipped`);
                }
            }

            if (mergedContent.trim() === '') {
                logDebugMessage('All custom files failed to process, not generating Merge.js');
                return { originalTotalBytes, fileEntries: [] };
            }

            // Process merged content
            let finalContent = mergedContent;

            // If minification needed and not yet done
            if (shouldMinify) {
                finalContent = minifyJs(finalContent);
                logDebugMessage(`Custom scripts minified, original size: ${formatBytes(originalMergedSize)}, minified: ${formatBytes(new TextEncoder().encode(finalContent).length)}`);
            }

            // Compress merged content
            const mergedUint8 = new TextEncoder().encode(finalContent);
            const compressed = await gzipCompress(mergedUint8);
            logDebugMessage(`Merge.js compression complete: ${formatBytes(compressed.length)}`);

            // Convert to Base64
            const base64Content = uint8ArrayToBase64(compressed);

            // Add to file entries
            mergeFileEntries.push({
                filename: 'Merge.js',
                content: base64Content
            });

            logDebugMessage('Merge.js generated and added to package list');
            return { originalTotalBytes, fileEntries: mergeFileEntries };
        }

        async function processAndDownload() {
            const downloadBtn = document.getElementById('downloadBtn');
            downloadBtn.disabled = true;
            updateProgress(0, 'Starting process...');
            clearDebugOutput();
            logDebugMessage('Starting packaging process');

            // Reset report and download link
            summaryReport.style.display = 'none';
            if (blobUrl) {
                URL.revokeObjectURL(blobUrl);
                blobUrl = null;
            }

            // Statistics
            let originalTotalBytes = 0;
            let jsFileBytes = 0;
            let outputFileName = 'blazor-resources.published.js'; // Default filename

            try {
                if (!window.CompressionStream) {
                    throw new Error('Browser does not support GZIP compression, please use latest Chrome, Edge, or Firefox');
                }

                // 1. Process user-specified custom JS file merging
                updateProgress(3, 'Processing custom files...');
                const customJsResult = await processCustomJsFiles(originalTotalBytes);
                originalTotalBytes = customJsResult.originalTotalBytes;
                const customFileEntries = customJsResult.fileEntries;

                // 2. Load and process blazor.boot.json
                logDebugMessage('Loading blazor.boot.json configuration file');
                updateProgress(5, 'Loading configuration file...');

                const bootJsonResponse = await fetch('_framework/blazor.boot.json');
                if (!bootJsonResponse.ok) {
                    throw new Error(`Unable to load blazor.boot.json (${bootJsonResponse.statusText})`);
                }

                // Get original content and size of blazor.boot.json
                const bootJsonText = await bootJsonResponse.text();
                const bootJsonBytes = new TextEncoder().encode(bootJsonText).length;
                originalTotalBytes += bootJsonBytes;
                logDebugMessage(`blazor.boot.json loaded successfully (${formatBytes(bootJsonBytes)})`);

                const bootJson = JSON.parse(bootJsonText);

                function formatNowDate() {
                    var date = new Date();
                    const pad = (num) => num.toString().padStart(2, '0');

                    const year = date.getFullYear();
                    const month = pad(date.getMonth() + 1); // getMonth() returns 0-11
                    const day = pad(date.getDate());
                    const hours = pad(date.getHours());
                    const minutes = pad(date.getMinutes());
                    const seconds = pad(date.getSeconds());

                    return `${year}-${month}-${day}-${hours}-${minutes}-${seconds}`;
                }

                // Determine output filename: user input takes priority
                const userFileName = outputFileNameInput.value.trim();
                if (userFileName) {
                    outputFileName = userFileName;
                    logDebugMessage(`Using user-specified filename: ${outputFileName}`);
                } else if (bootJson.entryAssembly) {
                    var dtm = new Date();
                    outputFileName = bootJson.entryAssembly + '.' + formatNowDate() + ".published.js";
                    logDebugMessage(`Using default filename: ${outputFileName}`);
                } else if (bootJson.mainAssemblyName) {
                    outputFileName = bootJson.mainAssemblyName + '.' + formatNowDate() + ".published.js";
                    logDebugMessage(`Using default filename: ${outputFileName}`);
                }

                updateProgress(10, 'Configuration file parsing complete');

                // 3. Collect list of files to process (all files listed in boot.json, force package)
                const filesToProcess = ["blazor.webassembly.js","dotnet.js"];
                const resourceTypes = ['runtime', 'assembly',
                    'runtimeAssets', 'pdb', 'jsModuleNative',
                    'jsModuleRuntime', 'wasmNative',
                    'icu', 'coreAssembly', 'fingerprinting'];
                resourceTypes.forEach(type => {
                    if (bootJson.resources && bootJson.resources[type]) {
                        const items = bootJson.resources[type];
                        Object.keys(items).forEach(filename => {
                            if (filesToProcess.indexOf(filename) < 0) {
                                filesToProcess.push(filename);
                            }
                        });
                    }
                });
                if (bootJson.appsettings) {
                    for(var item4 of bootJson.appsettings) {
                        filesToProcess.push(item4);
                    }
                }

                logDebugMessage(`Found ${filesToProcess.length} resource files to package`);
                updateProgress(15, 'Preparing to process files...');

                if (filesToProcess.length === 0 && customFileEntries.length === 0) {
                    throw new Error('No files to package found');
                }

                // 4. Process all files (including blazor.boot.json and custom merged files)
                const fileEntries = [...customFileEntries];

                // Add blazor.boot.json
                const bootJsonCompressed = await gzipCompress(new TextEncoder().encode(bootJsonText));
                const bootJsonBase64 = uint8ArrayToBase64(bootJsonCompressed);
                fileEntries.push({
                    filename: 'blazor.boot.json',
                    content: bootJsonBase64
                });
                logDebugMessage('blazor.boot.json processed');

                let processedCount = 0;
                const totalFiles = filesToProcess.length;
                const progressPerFile = totalFiles > 0 ? 75 / totalFiles : 0;
                var intRuntimeVersion = 7;
                for (const filename of filesToProcess) {
                    try {
                        updateProgress(15 + (processedCount * progressPerFile),
                            `Processing (${processedCount}/${totalFiles}): ${filename}`);
                        var url5 = new URL("_framework/" + filename, document.baseURI).href;
                        const fileResponse = await fetch(url5);
                        if (!fileResponse.ok) {
                            throw new Error(`Download failed (${fileResponse.statusText})`);
                        }

                        const arrayBuffer = await fileResponse.arrayBuffer();
                        var uint8Array = new Uint8Array(arrayBuffer);
                        if (filename.startsWith("dotnet.runtime.")
                            && uint8Array != null
                            && uint8Array.length > 10000) {
                            var strHeader44 = new TextDecoder().decode(uint8Array.slice(0,1000));
                            if (strHeader44.indexOf("e=\"9.") >= 0) {
                                intRuntimeVersion = 9;
                            }
                            else if (strHeader44.indexOf("e=\"8.") >= 0) {
                                intRuntimeVersion = 8;
                            }
                        }
                        const fileSize = uint8Array.length;
                        originalTotalBytes += fileSize;

                        const compressed = await gzipCompress(uint8Array);
                        const base64WithNewlines = uint8ArrayToBase64(compressed);

                        fileEntries.push({
                            filename: filename,
                            content: base64WithNewlines
                        });

                        processedCount++;
                        logDebugMessage(`Processed: ${filename} (${formatBytes(fileSize)})`);
                    } catch (error) {
                        logDebugMessage(`Error processing ${filename}: ${error.message}, skipped`);
                        processedCount++;
                    }
                }

                if (fileEntries.length <= (customFileEntries.length > 0 ? 1 : 0)) {
                    throw new Error('All resource files failed to process');
                }

                // 5. Generate output file, first line with current date and time
                logDebugMessage(`Generating output file: ${outputFileName}`);
                updateProgress(98, 'Generating output file...');

                // Get current date and time, formatted as: YYYY-MM-DD HH:MM:SS
                const now = new Date();
                const dateTimeStr = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')} ${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;

                // Build JS content, first line with date/time comment
                let jsContent = `// Gen at ${dateTimeStr} by https://github.com/dcsoft-yyf/BlazorWASMPackager
"use strict";
(async function () {
    if (window.__DCWriter5Started == true) {
        // Avoid duplicate calls
        return;
    }
    window.__DCWriter5Started = true;
    var allFileContents = {
                `;
                fileEntries.forEach((entry, index) => {
                    const isLastEntry = index === fileEntries.length - 1;
                    const key = escapeJsKey(entry.filename);
                    const escapedContent = entry.content.replace(/`/g, '\\`');
                    jsContent += `  ${key}: \`${escapedContent}\`${isLastEntry ? '' : ','}\n`;
                });

                jsContent += '};';
                jsContent += `
    // Get resource base path
    var bolDebugMode = false;
    function ConverToBoolean(strValue, bolDefaultValue) {
        if (strValue == null || strValue.length == 0) return bolDefaultValue;
        strValue = strValue.trim().toLowerCase();
        if (strValue == "true") return true;
        if (strValue == "false") return false;
        return bolDefaultValue;
    };
    if (document.currentScript != null) {
        bolDebugMode = ConverToBoolean(document.currentScript.getAttribute("debugmode"), false);
    }
    function GetFileExt( strFileName ){
        var index345 = strFileName.lastIndexOf('.');
        if (index345 > 0) {
            return strFileName.substring(index345).trim().toLowerCase();
        }
        return null;
    };
    var jsScript = document.createElement("script");
    jsScript.setAttribute("language", "javascript");
    jsScript.src = "_framework/blazor.webassembly.js";
    var strEnvironment = null;
    var mapBase64BlobUrl = {};
    if (window.DecompressionStream && allFileContents != null) {
        function StartsWith( strText , strHeader ){
            return strText.length >= strHeader.length
                && strText.substring( 0 , strHeader.length) == strHeader;
        };
        // Enable local Base64 resources
        /** Convert a Base64 string to a byte array, decompress with GZIP, and return an internal download URL */
        async function Base64ToBlobUrl(strBase64String, strFileName) {
            try {
                const binaryStr = atob(strBase64String);
                const uint8Array = new Uint8Array(binaryStr.length);
                for (let i = binaryStr.length - 1; i >= 0; i--) {
                    uint8Array[i] = binaryStr.charCodeAt(i);
                }
                const sourceStream = new Blob([uint8Array]).stream();
                const decompressedStream = sourceStream.pipeThrough(
                    new DecompressionStream('gzip')
                );
                const blob = await new Response(decompressedStream).blob();
                var strMimeType = "application/x-msdownload";
                if (strFileName != null) {
                    var strExt = GetFileExt( strFileName );
                    switch (strExt) {
                        case ".js": strMimeType = "application/javascript"; break;
                        case ".json": strMimeType = "application/json"; break;
                        case ".wasm": strMimeType = "application/wasm"; break;
                        case ".blat": strMimeType = "application/octet-stream"; break;
                        case ".dat": strMimeType = "application/octet-stream"; break;
                        case ".dll": strMimeType = "application/x-msdownload"; break;
                    }
                }
                const typedBlob = new Blob([blob], { type: strMimeType });
                const blobUrl = URL.createObjectURL(typedBlob);
                return blobUrl;
            } catch (error) {
                console.error('Conversion failed:', error);
                throw error;
            }
        }
        for (var key in allFileContents) {
            var strUrl44 = await Base64ToBlobUrl(allFileContents[key], key);
            if (strUrl44 != null && strUrl44.length > 0) {
                mapBase64BlobUrl[key] = strUrl44;
                if (key == "Merge.js") {
                    strEnvironment = strUrl44;
                }
                else if (key == "blazor.webassembly.js") {
                    jsScript.src = strUrl44;
                }
            }
        }
    }
    allFileContents = null;
    var myOriginalURL = null;
    `;
                if (intRuntimeVersion == 9 || intRuntimeVersion == 8) {
                    jsContent += `
    myOriginalURL = globalThis.URL || window.URL;
    var newURL = function(strUrl , strBase){
        this.toString = function () {
            return this.href;
        };
        if(strBase == null || strBase.length == 0 ){
            this.href = strUrl;
            return;
        }
        if (strUrl.length > 5 && strUrl.substring(0, 5) == "blob:") {
            this.href = strUrl;
            return;
        }
        if (strUrl == "./blazor.boot.json") {
            var strUrl4 = mapBase64BlobUrl["blazor.boot.json"];
            if (strUrl4 != null && strUrl4.length > 0) {
                this.href = strUrl4;
                return;
            }
        }
        if (strBase.length > 5 && strBase.substring( 0 , 5 ) == "blob:")
        {
            var strUrl5 = mapBase64BlobUrl[ strUrl];
            if (strUrl5 != null && strUrl5.length > 0 )
            {
                this.href = strUrl5;
            }
            return;
        }
        if (GetFileExt( strUrl ) == ".js")
        {
            var strUrl2 = mapBase64BlobUrl[strUrl];
            if (strUrl2 != null && strUrl2.length > 0) {
                this.href = strUrl2;
                return;
            }
        }
        return new myOriginalURL( strUrl , strBase);
    };
    globalThis.URL = newURL;`;
                }
                jsContent += `
    jsScript.setAttribute("autostart", "false");
    jsScript.onload = function () {
        Blazor.start({
            environment: strEnvironment,
            loadBootResource: function (type, name, defaultUri, integrity) {
                if (name == 'blazor.boot.json') {
                    // Support for micro-frontend framework MicroApp
                    if (window.__MICRO_APP_WINDOW__) {
                        __MICRO_APP_WINDOW__.document.defaultView.Blazor = window.Blazor;
                        __MICRO_APP_WINDOW__.document.defaultView.DotNet = window.DotNet;
                        if (window.rawWindow) {
                            window.rawWindow.Blazor = window.Blazor;
                            window.rawWindow.DotNet = window.DotNet;
                        }
                    }
                }
                // Support for micro-frontend framework QianKun
                if (window.__POWERED_BY_QIANKUN__) {
                    window.document.defaultView.Blazor = window.Blazor;
                    window.document.defaultView.DotNet = window.DotNet;
                }
                // If (GetFileExt( name ) == ".js") return '_framework/' + name;
                // Enable local Base64 resources
                var localUrl = mapBase64BlobUrl[name];
                if (localUrl != null && localUrl.length > 0) {
                    if (bolDebugMode == true) {
                        console.log("Load resource:" + name + "=>" + localUrl);
                    }
                    return localUrl;
                }
                return name;
            }
        }).then(function () {
            // Release mapBase64BlobUrl
            for (var key in mapBase64BlobUrl) {
                var strUrl555 = mapBase64BlobUrl[key];
                if (myOriginalURL == null ){
                    URL.revokeObjectURL(strUrl555);
                }
                else{
                    myOriginalURL.revokeObjectURL(strUrl555);
                }
            }
            mapBase64BlobUrl = null;
            if (myOriginalURL != null){
                globalThis.URL = myOriginalURL;
                myOriginalURL = null;
            }
        });
    };
    document.head.appendChild(jsScript);
})();
                `;
                // Calculate JS file size (UTF-8 encoding)
                const encoder = new TextEncoder();
                const jsUint8Array = encoder.encode(jsContent);
                jsFileBytes = jsUint8Array.length;

                // Create file and set download link
                const blob = new Blob([jsContent], { type: 'application/javascript' });
                blobUrl = URL.createObjectURL(blob);

                // Auto download
                const a = document.createElement('a');
                a.href = blobUrl;
                a.download = outputFileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                // Set manual download link
                manualDownloadLink.href = blobUrl;
                manualDownloadLink.download = outputFileName;
                manualDownloadLink.textContent = `Manually download ${outputFileName}`;
                manualDownloadLink.scrollIntoView();
                // Calculate compression ratio
                const compressionRatio = (jsFileBytes / originalTotalBytes * 100).toFixed(2) + '%';

                // Show summary report
                document.getElementById('originalTotalSize').textContent = formatBytes(originalTotalBytes);
                document.getElementById('jsFileSize').textContent = formatBytes(jsFileBytes);
                document.getElementById('compressionRatio').textContent = compressionRatio;
                summaryReport.style.display = 'block';

                updateProgress(100, 'Processing complete!');
                logDebugMessage(`Packaging complete! Generated ${outputFileName}`);
                logDebugMessage(`Summary: Original total size ${formatBytes(originalTotalBytes)}, Generated file size ${formatBytes(jsFileBytes)}, Compression ratio ${compressionRatio}`);
            } catch (error) {
                logDebugMessage(`Error: ${error.message}`);
                updateProgress(0, 'Processing failed, see log');
            } finally {
                downloadBtn.disabled = false;
                setTimeout(resetProgressBar, 1000);
            }
        }

        // Release blob URL when page unloads
        window.addEventListener('beforeunload', () => {
            if (blobUrl) {
                URL.revokeObjectURL(blobUrl);
            }
        });
    </script>
</body>
</html>



